# SeversteelTestTask_Probe
# Тестовое задание

## Исходная формулировка
**Тестовое задание кандидата на должность backend-разработчик С#** 
 
**Задача**: Система управления заказами с использованием микросервисной архитектуры. 
**Сценарий**: Необходимо разработать систему управления заказами для пункта выдачи, используя микросервисный подход. Система должна включать в себя два независимых микросервиса, взаимодействующих между собой. 
**Требования**:  
1.  Сервис 1 
-  Хранит информацию о товарах (Артикул, Наименование, Описание, Цена, Наличие на складе) и заказах (Номер заказа, Количество товаров в заказе, Дата оформления, Хранение до (дата и время), Статус заказа, ФИО клиента, Номер телефона, Стоимость). 
-  Предоставляет REST API для получения информации о товарах, заказах, деталях заказа. 
-  Использует БД для хранения данных. 
2.  Сервис 2 
-  Обрабатывает создание и отмену заказа, изменение статуса заказа, редактирование 
заказа (удалить/добавить товар). 
-  Предоставляет REST API для управления заказами. 

## Важно! Интерпретация задачи
 В задаче есть принципиальный момент, оставшийся для меня неясным и кардинально повлиявший на все решение: данные, за которые отвечает сервис 2 (управление заказами), хранятся в сервисе 1. Это выглядит противоречащим принципам микросервисной архитектуры, по которым микросервис должен обладать данными, которыми управляет. Поэтому в реальной задаче я бы в первую очередь поставил вопрос - не стоит ли перенести данные заказов в микросервис 2 (если нужно использовать микросервисы). В текущем же виде это похоже на архитектурную проблему, создающую избыточные взаимодействия (или я что-то очень важное упускаю из виду). С учетом всего этого я воспринял задачу как подчеркнуто тренировочную.
 
## Замечания о принятых решениях
1.  Выбор способа взаимодействия микросервисов. Я рассматривал варианты использования асинхронного обмена с брокером сообщений и синхронного взаимодействия по REST API. С учетом того, что по условию задачи предполагается REST, но не предполагаются средства уведомлений клиента со стороны сервиса (напр. WebSocket и др.), я решил, что предполагается использование синхронного взаимодействия по REST, хотя такое решение для микросервисной архитектуры не считается удачным. 
2. С учетом п.1 роль сервиса 2 может либо сводиться к чистой прослойке, пересылающей запросы на сервис 1, либо к выполнению бизнес-логики, но с совершением дополнительного обращения к сервису 1 для чтения данных. Для оправдания существования сервиса 2 я выбрал последний вариант, и в предлагаемом решении сервис 2 содержит некоторую бизнес-логику и часто обращается к сервису 1 :) Решение показало, что такой подход быстро приводит к ненужному усложнению. Кроме того, нужно как-то искусственно прятать API сервиса 1, изменяющее данные в БД.
3. Разделение хранения данных и их бизнес-логики усложняет поддержание консистентности данных, особенно при синхронном взаимодействии. Так, в предлагаемом решении не обеспечивается консистентность при конкурентном обращении на изменение заказов.
4. Проект разворачивался и тестировался на Docker, 3 контейнера - под сервисы и БД, докерфайлы и docker-compose содержатся в решении, можно запустить сразу из Visual Studio. Используются порты хоста 5001, 5002 (сервис 1), 5003, 5004 (сервис 2), 5435 (БД).
5. В качестве СУБД используется PostgreSQL, при каждом новом запуске база пересоздается и заполняется небольшим количеством тестовых данных. В схеме предусмотрено отдельное (от сущности товара) хранение цены для позиций заказа на момент его создания.
6. В проекте использована простейшая архитектура без разделения на слои из-за малых масштабов задачи. В сервисе 2 предусмотрен один интерфейс-сервис для работы с бизнес-логикой.
7. В REST API предусмотрены только методы, непосредственно вытекающие из задачи. Например, возможности создать или изменить товар через REST не предусмотрено.
8. Для организации возврата успешного результата и ошибок бизнес-логики (без использования исключений для реализации control flow) используется Result-паттерн. Для поимки необработанных исключений используется отдельный middleware, в текущем решении не производящий никакой особенной обработки.